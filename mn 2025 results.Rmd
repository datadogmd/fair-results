---
title: "MN 2025 Results"
author: "MaDuSa"
date: "2025-09-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r libraries}
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(pdftools))
suppressPackageStartupMessages(library(stringr))
```


```{r constants}
resultsPageHeadTail <- c("MINNESOTA STATE FAIR", "Page")
creativeActivity <- "Creative Activities"
em_dash <- " \u2014 "
winnerListSeparator = " {3,}" # split by 3 or more blank spaces
stateSeparator <- ", "
eol <- "\n"
classCode <- NULL
classDescriptor1 <- NULL
entryCountFlag <- " Entries in "
classTypeList <- c("class", "lot")
classCount <- NULL
classDescriptor2 <- NULL
entryCount <- NULL
entryRank <- NULL
entryName <- NULL # firstname lastname
entryGuild <- NULL
entryCity <- NULL # city, state abbreviation
entryState <- NULL
honerableMention <- "HM"
runnerUp <- "runner-up"

```


```{r load pdf}

#pdfPath <- "D:/data/state fair/mn"
pdfPath <- "C:/Users/mdusa/Documents/mdusaire50/analytics/data/mn"
fileList <- dir(pdfPath)
wholePage <- pdftools::pdf_text(paste(pdfPath, fileList[1], sep = "/"))

```

pageLines is approximately twice as large as wholePage

Some classes, such as Sweepstakes, may be missing "Entries in class:". I add and entry for these rows.

Get class info

The class info contains:
* class code (which may be different every year)
* class name
* class qualifiers
* class entries count

```{r functions}

insertMissingDescriptor <- function(pageLines, missingDescriptorIndex) {
  
  arrayLength <- length(pageLines)
  nShifts <- length(missingDescriptorIndex)
  
  if (nShifts > 0) {
    for (i in 1:nShifts) {
      pageLines[(missingDescriptorIndex[i] + 1):(arrayLength + 1)] <-
        pageLines[missingDescriptorIndex[i]:arrayLength]
      pageLines[missingDescriptorIndex[i]] <- "None"
      
      # Update target rows to account for new row inserted above.
      missingDescriptorIndex[i + 1] <- missingDescriptorIndex[i + 1] + i
      
      # Update arrayLength to account for newly inserted row.
      arrayLength <- length(pageLines)
    }
  }
  return(pageLines)
}


multiLineMerge <- function(pageLines, targetLines) {
  
  nTargetLines <- length(targetLines)
  if (nTargetLines != 0) {
    linesToMerge <- targetLines - 1
    
    for (i in 1:nTargetLines) {
      insertClassDescriptorHere <- max(unlist(gregexpr(entryCountFlag, pageLines[targetLines[i] - 1])
      )
      ) - 1
      pageLines[targetLines[i] - 1] <- 
        paste0(substr(pageLines[targetLines[i] - 1], 1,
                      insertClassDescriptorHere), " ",
               pageLines[targetLines[i]], " ",
               substr(pageLines[targetLines[i] - 1],
                      (insertClassDescriptorHere + 1),
                      nchar(pageLines[targetLines[i] - 1])
               )
        )
    }
    
    # Removed now redundant lines in multi-line descriptors
    pageLines <- pageLines[-targetLines]
  }
  return(pageLines)
}



getFirstWinners <- function(pageLines) {
  
  # Get indices for first position in each list of winners
  
  winnerLines <- which(grepl("^[0-9] {3}", pageLines))
  winnerLinesDiff <- diff(c(0,winnerLines))
  
  # pageLines[winnerLines[winnerLinesDiff != 1]]
  
  return(winnerLines[winnerLinesDiff != 1])
}



regex_between <- function(start_str, end_str, page_ln) {
  
  # Construct the regular expression
  # The '.*?' is a non-greedy match for any characters between the two patterns
  regex_pattern <- paste0(start_str, "(.*?)\\", end_str)
  
  # Find the starting and ending positions of the match
  match_info <- regexpr(regex_pattern, page_ln, perl = TRUE)
extracted_string <- substr(page_line, 
                             attr(match_info, "capture.start")[1], 
                             attr(match_info, "capture.start")[1] + attr(match_info, "capture.length")[1] - 1)
  extracted_string <- trimws(extracted_string, which = "both")
  return(extracted_string)
} 


```


```{r get year remove head and tail}

pageLines <- unlist(strsplit(wholePage, "\n")) # using base-R
lengthPageLines <- length(pageLines)

# Remove leading blanks

# pageLines <- trimws(pageLines, which = "left")

# Identify head and tail rows

pageHeadIndex <- which(grepl(resultsPageHeadTail[1], pageLines))
pageTailIndex <- which(grepl("\\d{1,2}:\\d{2}:\\d{2}", pageLines))

year <- strsplit(pageLines[pageHeadIndex[1]], " ")[[1]][1]
activity <- strsplit(pageLines[pageHeadIndex[1] + 1], "[:-]")[[1]][2]

# Remove head and tail rows

pageLines <- pageLines[-sort(c(pageHeadIndex, pageHeadIndex + 1, pageTailIndex))]
lengthPageLines <- length(pageLines)

```


```{r get class type}

# Detect classType

classType <- pageLines[grep(entryCountFlag, pageLines)[1]] %>%
  strsplit(split = entryCountFlag)
classType <- str_trim(strsplit(classType[[1]][2], ":")[[1]][1], side = "both")
class_type_title <- str_to_title(classType) # If you don't capitalize, then words like "Cloth" trigger unwanted actions.

classDelimiter <- paste0(class_type_title, ".*", "\u2014")

```


```{r add entry count tag where missing}

classRows <- grepl(classDelimiter, pageLines) # Row numbers for Class information
classRowIndex <- which(classRows)
# length(classRowIndex)

missingEntryCount <- is.na(str_match(pageLines[classRows], entryCountFlag))

# Rows with no "Entries in" flag

noClassEntryCount <- pageLines[classRows][missingEntryCount]

pageLines[classRows][missingEntryCount] <- paste(noClassEntryCount, " ", entryCountFlag, " ",
                                                 classType, ": ", "1", sep = "")

```


```{r merge split line descriptions}

# Merge split lines.  It appears that split line class descriptions are non-empty lines with less than 2 blanks at the beginning of the string.

blankLines <- pageLines == ""
multiLines <- !grepl("^[[:blank:]]{2}", pageLines) & !classRows & !blankLines

# The lines immediately following the Class descriptor with one or fewer blanks is likely part of a multi-line descriptor. A blank line immediately following the Class descriptor usually corresponds to a missing secondary class descriptor.  These are considered later.

multiLineRow <- (which(multiLines) - 1) %in% classRowIndex

targetLines <- which(multiLines)[multiLineRow]

pageLines <- multiLineMerge(pageLines, targetLines)

classRows <- grepl(classDelimiter, pageLines) # Row numbers for Class information
classRowIndex <- which(classRows)

```


```{r add missing secondary class descriptor}

# Find empty lines or winner rows immediately following a Class row.

secondDescriptor <- rep(FALSE, length(pageLines))
secondDescriptor[which(classRows) + 1] <- TRUE

blankLines <- pageLines == ""

winnerRows <- grepl("^[0-9] {3}", trimws(pageLines, which = "left"))

# Blank lines and winner rows immediately following the Class row should be replaced with the class identifier:  None

missingDescriptor <- (winnerRows | blankLines) & secondDescriptor

pageLines <- insertMissingDescriptor(pageLines, which(missingDescriptor))

```



```{r remove blank lines and split winner rows}
blankLines <- pageLines == ""
pageLines <- pageLines[-which(blankLines)]

winnerRows <- grepl("^[0-9] {3}", trimws(pageLines, which = "left"))
#which(blankLines)
#pageLines[-which(blankLines)]

```


```{r winners list identifier}

# Add comma delimiters to winnerRows
winnerRows <- grepl("^[0-9] {3}", trimws(pageLines, which = "left"))
winnerRowIndex <- which(winnerRows)
pageLines[winnerRows] <- gsub(" {4,}", ", ", trimws(pageLines[winnerRows], which = "left"))

# pageLines[which(winnerRows)] <- gsub(" {4,}", ", ", pageLines[which(winnerRows)])

# Number of commas in the winner rows is equivalent to the number of columns in the row.  Most will have 3 commas: Rank, Firstname Lastname, City Name, State Abbreviation.  Some may have multiple participants per line, or a guild name.  Find the maximum for the document and add the extra columns + 2 before the City Name.

splitWinnerRows <- strsplit(pageLines[winnerRows], ",")

firstColumns <- lapply(splitWinnerRows,
                       function(x) {
                         l = length(x)
                         x[1:(l-2)]
                       })

replacementColumns <- lapply(splitWinnerRows,
                             function(x, n=6) {
                               l = length(x)
                               paste(strrep(" , ", (n-l)), x[l-1], " , ", x[l])
                             }
)

newWinnerRowsList <- mapply(c, firstColumns, replacementColumns, SIMPLIFY = TRUE)

newWinnerRows <- lapply(newWinnerRowsList, function(x) {
  paste(x, collapse = ",")
}
)

pageLines[winnerRows] <- newWinnerRows

pageLines <- unlist(pageLines)

# Winner rows should now each have 6 columns.  Rows with more columns are due to:
# data entry errors that include a zipcode at the end of the winner row. We will either ignore this additional information or ignore the whole entry.

pageLines
```


```{r transform into a long dataframe}

# Associate each class with the secondary descriptor and a list of winners

class_rows_grepl <- grepl(classDelimiter, pageLines) # Row numbers for Class information

winnerRows <- grepl("^[0-9] {3}", trimws(pageLines, which = "left"))
winnerRowIndex <- which(winnerRows)
pageLines[winnerRows] <- gsub(" {4,}", ", ", pageLines[winnerRows])


class_rows <- which(class_rows_grepl)
n_class_rows <- length(class_rows)
class_group_steps <- diff(class_rows) - 1
class_group_steps[n_class_rows] <- length(class_rows_grepl) - class_rows[n_class_rows]

for (i in 1:n_class_rows) {
  cr_start <- class_rows[i]
  cr_end <- cr_start + class_group_steps[i]
  cr_seq <- seq(cr_start, cr_end)
  page_line <- pageLines[cr]
classInfo <- function(page_ln, i) {

  page_line <- pageLines[cr]
 pageLines[class_seq] 
  class_rows
  # First line of the Class group contains the class code, class description (long) and entrant count.
  start_string <- classTypeTitle
  end_string <- em_dash  
  classCode <- regex_between(start_string, end_string, page_line)
  classCode
  start_string <- em_dash
  end_string <- entryCountFlag
class_description_long <- regex_between(start_string, end_string, page_line)
class_description_long
 
  classCount <- strsplit(page_line, ": ")[[1]][2] |>
                  trimws(, which = "both")
  classCount
  # The second line of the Class group contains the secondary class description (short)
  page_line <- pageLines[classRowIndex[i + 1]]

   class_group <- seq(from = i, length.out = classStep[i])
   n_class_group <- length(class_group)
   
   
   for (j in 3:n_class_group) {
     
     
   }
   
   
   
  pageLines
  startString <- "Supreme"
  endString <- "Award"
  

}
  
}
```