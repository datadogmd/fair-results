---
title: "MN 2025 Results"
author: "MaDuSa"
date: "2025-09-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r libraries}
suppressPackageStartupMessages(library(pdftools))
# library(rJava)
# library(tabulapdf)
# library(readr)
# library(R.utils)
 library(stringr)
# library(writexl)
```

```{r markers}
year <- "2025"
mnResultsPageTitle <- paste(year, "MINNESOTA STATE FAIR RESULTS", sep = "")
creativeActivity <- "Creative Activities:"
em_dash <- " \u2014 "
twoSpaces <- "  "
winnerListSeparator = " {3,}" # split by 3 or more blank spaces
singleComma <- ","
stateSeparator <- ", "
eol <- "\n"
classCode <- NULL
classDescriptor1 <- NULL
entryCountFlag <- "Entries in"
classTypeList <- c("class", "lot")
classCount <- NULL
classDescriptor2 <- NULL
entryCount <- NULL
entryRank <- NULL
entryName <- NULL # firstname lastname
entryGuild <- NULL
entryCity <- NULL # city, state abbreviation
entryState <- NULL
honerableMention <- "HM"
runnerUp <- "runner-up"

```



```{r load pdf}

#pdfPath <- "D:/data/state fair/mn"
pdfPath <- "C:/Users/mdusa/Documents/mdusaire50/analytics/data/mn"
fileList <- dir(pdfPath)
wholePage <- pdftools::pdf_text(paste(pdfPath, fileList[4], sep = "/"))

```

pageLines is approximately twice as large as wholePage

Some classes, such as Sweepstakes, may be missing "Entries in class:". I add and entry for these rows.

 Get class info

 The class info contains:
    * class code (which may be different every year)
    * class name
    * class qualifiers
    * class entries count



```{r parse pdf as pageLines}

 # Using wholePage might be more efficient than breaking the page into lines, but I break the page into lines and proceed with pageLines.

# pageLines <- read_lines(wholePage) # using readr function

pageLines <- unlist(strsplit(wholePage, "\n")) # using base-R

 # This process might remove the EOL character from the end of the line of text.

# Remove blank lines

# pageLinesNoBlanks <- pageLines[-which(pageLines == "")]

# Might not want to remove the blank lines yet.

pageLinesNoBlanks <- pageLines

# In the original process I removed the extra spaces using str_squish, but those spaces may be useful for field separation later.Remove extra blank spaces

# pageLinesSquish <- str_squish(pageLinesNoBlankLines)

# Add "Entries in class: 1" to rows that are missing the "Entries in class:" info

# Detect classType
 
 classType <- pageLinesNoBlanks[grep(entryCountFlag, pageLinesNoBlanks)[1]] %>%
   strsplit(split = entryCountFlag)
 classType <- str_trim(strsplit(classType[[1]][2], ":")[[1]][1], side = "both")


 # Add "Entries in" information to any Class rows that do not contain this flag.  These usually correspond to special classes which only have one entry. Add and "Entries in" with a count of 1.

 classTypeTitle <- str_to_title(classType) # If you don't capitalize, then words like "Cloth" trigger unwanted actions.
 
  classDelimiters <- paste0(classTypeTitle, ".*", "\u2014")

 classRows <- grep(classDelimiters, pageLinesNoBlanks) # Row numbers for Class information
 # pageLinesNoBlanks[classRows]
 
 missingEntryCountFlag <- is.na(str_match(pageLinesNoBlanks[classRows],entryCountFlag))
 
 # Rows with no "Entries in" flag
 
 noClassEntryCount <- pageLinesNoBlanks[classRows][missingEntryCountFlag]

 pageLinesNoBlanks[classRows][missingEntryCountFlag] <- paste(noClassEntryCount, " ", entryCountFlag, " ",
                                                              classType, ": ", "1", sep = "")

 # Some class descriptions extend more than a single line. Merge the multi-line class descriptors into a single line. Assuming the last final comments on the class description line contains text in parentheses, un-paired parentheses may identify these "mid-line carriage returns. Paste the extra text before the Entries in class: flag, and delete the extra line in pageLinesNoBlanks.  This does not account for multi-line descriptions that are not in parentheses, or those with matching pairs of parentheses.
 
 splitLineDescriptors <- which(str_count(pageLinesNoBlanks, "\\(") - str_count(pageLinesNoBlanks, "\\)") != 0)

 if (length(splitLineDescriptors) != 0) {
oddIndices <- seq(1, length(splitLineDescriptors), 2)
evenIndices <- seq(2, length(splitLineDescriptors), 2)

for (i in oddIndices) {
  pageLinesNoBlanks[splitLineDescriptors[i]]
  pageLinesNoBlanks[splitLineDescriptors[i + 1]]
  insertClassDescriptorHere <- max(unlist(gregexpr(entryCountFlag,
                                       pageLinesNoBlanks[splitLineDescriptors[i]]
                                              )
                                      )
                               ) - 1
  pageLinesNoBlanks[splitLineDescriptors[i]] <- 
    paste0(substr(pageLinesNoBlanks[splitLineDescriptors[i]], 1,
                  insertClassDescriptorHere),
           pageLinesNoBlanks[splitLineDescriptors[i + 1]],
           substr(pageLinesNoBlanks[splitLineDescriptors[i]],
                  insertClassDescriptorHere,
                  nchar(pageLinesNoBlanks[splitLineDescriptors[i]])
                  )
           )
}

# Removed now redundant lines in multi-line descriptors
pageLinesNoBlanks <- pageLinesNoBlanks[-splitLineDescriptors[evenIndices]]
 }
 
#pageLinesNoBlanks
```


```{r none listed class identifier}

# Recalculate classRows because some rows have been removed from pageLinesNoBlanks during the multi-line descriptor manipulation step.

classRows <- grep(classDelimiters, pageLinesNoBlanks) # Row numbers for Class information
 # The lines below the line with the class identifier contains a class "keyword".  Separate this out.

# The next lines following the classRows contain the additional class keyword
# pageLinesNoBlanks[classRows]
classKeyRows <- classRows + 1
#pageLinesNoBlanks[classKeyRows]

# For Classes that do not have a keyword or blank row between the "Class" flag and the winner list will erroneously tag the first place info as the class keyword row.  These could be identified by having a "1" in the second column.  These rows could be excluded by first inserting a keyword of "None listed" above the first winner row, and re-parsing the text.

insertNoneListedHere <- classKeyRows[which(lengths((str_split(pageLinesNoBlanks[classKeyRows], pattern =
                                                   winnerListSeparator))) > 1)]

arrayLength <- length(pageLinesNoBlanks)
nShifts <- length(insertNoneListedHere)

if (nShifts > 0) {
  for (i in 1:nShifts) {
    pageLinesNoBlanks[(insertNoneListedHere[i] + 1):(arrayLength + 1)] <-
      pageLinesNoBlanks[insertNoneListedHere[i]:arrayLength]
    pageLinesNoBlanks[insertNoneListedHere[i]] <- "None listed"

        # Update target rows to account for new row inserted above.
    insertNoneListedHere[i + 1] <- insertNoneListedHere[i + 1] + i

        # Update arrayLength to account for new row inserted above.
    arrayLength <- length(pageLinesNoBlanks)
  }
}

length(pageLinesNoBlanks)

classRows <- grep(classDelimiters, pageLinesNoBlanks) # Row numbers for Class information
pageLinesNoBlanks[classRows]
classKeyRows <- classRows + 1
pageLinesNoBlanks[classKeyRows]

#pageLinesNoBlanks
```


```{r winners list identifier}
# Remove leading blanks
pageLinesNoBlanks <- trimws(pageLinesNoBlanks, which = "left")

firstPlaceWinners <- which(grepl(paste0("^", "1"), pageLinesNoBlanks))
secondPlaceWinners <- which(grepl(paste0("^", "2"), pageLinesNoBlanks))
classRows <- grep(classDelimiters, pageLinesNoBlanks)


pageLinesNoBlanks[firstPlaceWinners]

classKeyRows[which(lengths(str_split(pageLinesNoBlanks[classKeyRows], pattern =
                                                   winnerListSeparator)) > 1)]



pageLinesNoBlanks[which(lengths(str_split(pageLinesNoBlanks[], pattern = winnerListSeparator)) > 2)]


lineNumber <- 10
pageLinesNoBlanks[lineNumber]
firstNonBlankChar <- regexpr("\\S", pageLinesNoBlanks[lineNumber])[1]
firstChar <- substr(pageLinesNoBlanks[lineNumber], firstNonBlankChar, firstNonBlankChar)
firstChar






```


```{r column dividers}
# replace large spaces with a comma
This is the next stage of parsing




```

```{r}

# classDelimiters <- c("\u2014|,|//|and|or|and/or|(|)|(?<=class:)|(?<=lot:)")
# classDelimiters <- c("\u2014|,|and|or|(?<=class:)|(?<=lot:)")
# classDelimiters <- c("\u2014|,|and|or|(?<=Entries in class:)|(?<=Entries in lot:)")
 classDelimiters <- c("\u2014|(Entries in class:)|(Entries in lot:)")
 
winnersDelimiters <- c(",")


#  Identify the Class rows and parse these for class info

# matchInfo <- gregexpr(classDelimiters, pageLinesNoBlanks)

# Get class info

# The class info contains:
#    class code (which may be different every year)
#    class name
#    class qualifiers
#    class entries count

#matchInfo <- gregexpr(classHeader, pageLinesNoBlanks)


sapply(pageLinesNoBlanks[], str_count())

# str_match(pageLinesNoBlanks[classRows], " 1 ")
# pageLinesNoBlanks[classRows[1]+1:classRows[2]-1]
# winnerSteps <- diff(classRows, lag = 1)
# pageLinesNoBlanks[4]
# classRows[2] - classRows[1]
# pageLinesNoBlanks[6]

# Locate rows with no "Entries in" info.

 



classInfo <- str_split(pageLinesSquish[classRows], classType)

head(classInfo)

classInfoEntriesCount <- str_split(sapply(classInfo, "[[", 2), classDelimiters)

classInfoIds <- sapply(classInfoEntriesCount, "[[", 1) # as.numeric()
classInfoCategories <- sapply(classInfoEntriesCount, "[[", 2) # str_trim(x, side = "both")
# str_trim(classInfoCategories, side = "both")
classInfoEntryCounts <- sapply(classInfoEntriesCount, "[[", 3) # as.numeric()




classInfoCategories

pageLinesNoBlankLines <- classInfo[-which(classInfo[][] == "")]

str_split(pageLinesNoBlankLines, winnersDelimiters)

step1 <- strsplit(pageLinesNoBlankLines[searchMatch[]], delimiters)
step2 <- strsplit(step1[[1]][2], classEntryCount)
step3 <- strsplit(step2[[1]][1], delimeters)

searchMatch[1]
length(searchMatch)

matchInfo[[searchMatch[1:length(searchMatch)]]][]
matchInfo[noMatch] <- NULL

regmatches(pageLines[], matchInfo)

matchCount <- length(matchInfo[[1]])
matchInfoValue <- matchInfo

# Modify starting position to first character after searchString

matchInfoValue[[1]][1:matchCount] <- matchInfo[[1]][1:matchCount] + nchar(searchString)

# Modify the match.length to the length of the desired string

attr(matchInfoValue[[1]], "match.length")[1:matchCount] <- targetInfoLength
regmatches(pageLines[], matchInfoValue)


```