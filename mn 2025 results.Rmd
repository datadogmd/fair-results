---
title: "MN 2025 Results"
author: "MaDuSa"
date: "2025-09-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r libraries}
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(pdftools))
suppressPackageStartupMessages(library(stringr))
```


```{r markers}

resultsPageHeadTail <- c("MINNESOTA STATE FAIR", "Page")
creativeActivity <- "Creative Activities:"
em_dash <- " \u2014 "
twoSpaces <- "  "
winnerListSeparator = " {3,}" # split by 3 or more blank spaces
singleComma <- ","
stateSeparator <- ", "
eol <- "\n"
classCode <- NULL
classDescriptor1 <- NULL
entryCountFlag <- "Entries in"
classTypeList <- c("class", "lot")
classCount <- NULL
classDescriptor2 <- NULL
entryCount <- NULL
entryRank <- NULL
entryName <- NULL # firstname lastname
entryGuild <- NULL
entryCity <- NULL # city, state abbreviation
entryState <- NULL
honerableMention <- "HM"
runnerUp <- "runner-up"

```


```{r load pdf}

#pdfPath <- "D:/data/state fair/mn"
pdfPath <- "C:/Users/mdusa/Documents/mdusaire50/analytics/data/mn"
fileList <- dir(pdfPath)
wholePage <- pdftools::pdf_text(paste(pdfPath, fileList[1], sep = "/"))

```

pageLines is approximately twice as large as wholePage

Some classes, such as Sweepstakes, may be missing "Entries in class:". I add and entry for these rows.

Get class info

The class info contains:
* class code (which may be different every year)
* class name
* class qualifiers
* class entries count

```{r functions}

insertMissingDescriptor <- function(pageLines, missingDescriptorIndex) {
  
  arrayLength <- length(pageLines)
  nShifts <- length(missingDescriptorIndex)
  
  if (nShifts > 0) {
    for (i in 1:nShifts) {
      pageLines[(missingDescriptorIndex[i] + 1):(arrayLength + 1)] <-
        pageLines[missingDescriptorIndex[i]:arrayLength]
      pageLines[missingDescriptorIndex[i]] <- "None"
      
      # Update target rows to account for new row inserted above.
      missingDescriptorIndex[i + 1] <- missingDescriptorIndex[i + 1] + i
      
      # Update arrayLength to account for newly inserted row.
      arrayLength <- length(pageLines)
    }
  }
  return(pageLines)
}


multiLineMerge <- function(pageLines, targetLines) {
  
  nTargetLines <- length(targetLines)
  if (nTargetLines != 0) {
    linesToMerge <- targetLines - 1
    
    for (i in 1:nTargetLines) {
      insertClassDescriptorHere <- max(unlist(gregexpr(entryCountFlag, pageLines[targetLines[i] - 1])
      )
      ) - 1
      pageLines[targetLines[i] - 1] <- 
        paste0(substr(pageLines[targetLines[i] - 1], 1,
                      insertClassDescriptorHere), " ",
               pageLines[targetLines[i]], " ",
               substr(pageLines[targetLines[i] - 1],
                      (insertClassDescriptorHere + 1),
                      nchar(pageLines[targetLines[i] - 1])
               )
        )
    }
    
    # Removed now redundant lines in multi-line descriptors
    pageLines <- pageLines[-targetLines]
  }
  return(pageLines)
}



getFirstWinners <- function(pageLines) {
  
  # Get indices for first position in each list of winners
  
  winnerLines <- which(grepl("^[0-9] {3}", pageLines))
  winnerLinesDiff <- diff(c(0,winnerLines))
  
  # pageLines[winnerLines[winnerLinesDiff != 1]]
  
  return(winnerLines[winnerLinesDiff != 1])
}

```


```{r get year remove head and tail}

pageLines <- unlist(strsplit(wholePage, "\n")) # using base-R
lengthPageLines <- length(pageLines)

# Remove leading blanks

# pageLines <- trimws(pageLines, which = "left")

# Identify head and tail rows

pageHeadIndex <- which(grepl(resultsPageHeadTail[1], pageLines))
pageTailIndex <- which(grepl(resultsPageHeadTail[2], pageLines))

year <- strsplit(pageLines[pageHeadIndex[1]], " ")[[1]][1]
activity <- strsplit(pageLines[pageHeadIndex[1] + 1], ": ")[[1]][2]

# Remove head and tail rows

pageLines <- pageLines[-sort(c(pageHeadIndex, pageHeadIndex + 1, pageTailIndex))]
lengthPageLines <- length(pageLines)

```


```{r get class type}

# Detect classType

classType <- pageLines[grep(entryCountFlag, pageLines)[1]] %>%
  strsplit(split = entryCountFlag)
classType <- str_trim(strsplit(classType[[1]][2], ":")[[1]][1], side = "both")
classTypeTitle <- str_to_title(classType) # If you don't capitalize, then words like "Cloth" trigger unwanted actions.

classDelimiter <- paste0(classTypeTitle, ".*", "\u2014")

```


```{r add entry count tag where missing}

classRows <- grepl(classDelimiter, pageLines) # Row numbers for Class information
classRowIndex <- which(classRows)
# length(classRowIndex)

missingEntryCount <- is.na(str_match(pageLines[classRows], entryCountFlag))

# Rows with no "Entries in" flag

noClassEntryCount <- pageLines[classRows][missingEntryCount]

pageLines[classRows][missingEntryCount] <- paste(noClassEntryCount, " ", entryCountFlag, " ",
                                                 classType, ": ", "1", sep = "")

```


```{r merge split line descriptions}

# Merge split lines.  It appears that split line class descriptions are non-empty lines with less than 2 blanks at the beginning of the string.

blankLines <- pageLines == ""
multiLines <- !grepl("^[[:blank:]]{2}", pageLines) & !classRows & !blankLines

# The lines immediately following the Class descriptor with one or fewer blanks is likely part of a multi-line descriptor. A blank line immediately following the Class descriptor usually corresponds to a missing secondary class descriptor.  These are considered later.

multiLineRow <- (which(multiLines) - 1) %in% classRowIndex

targetLines <- which(multiLines)[multiLineRow]

pageLines <- multiLineMerge(pageLines, targetLines)

classRows <- grepl(classDelimiter, pageLines) # Row numbers for Class information
classRowIndex <- which(classRows)

```


```{r add missing secondary class descriptor}

# Find empty lines or winner rows immediately following a Class row.

secondDescriptor <- rep(FALSE, length(pageLines))
secondDescriptor[which(classRows) + 1] <- TRUE

blankLines <- pageLines == ""

winnerRows <- grepl("^[0-9] {3}", trimws(pageLines, which = "left"))

# Blank lines and winner rows immediately following the Class row should be replaced with the class identifier:  None

missingDescriptor <- (winnerRows | blankLines) & secondDescriptor

pageLines <- insertMissingDescriptor(pageLines, which(missingDescriptor))

```



```{r remove blank lines and split winner rows}
blankLines <- pageLines == ""
pageLines <- pageLines[-which(blankLines)]

winnerRows <- grepl("^[0-9] {3}", trimws(pageLines, which = "left"))
#which(blankLines)
#pageLines[-which(blankLines)]

```


```{r winners list identifier}

# Add comma delimiters to winnerRows

csvWinnerRows <- gsub(" {4,}", ", ", pageLines[winnerRows])

# Number of commas in the winner rows is equivalent to the number of columns in the row.  Most will have 3 commas: Rank, Firstname Lastname, City Name, State Abbreviation.  Some may have multiple participants per line, or a guild name.  Find the maximum for the document and add the extra columns + 2 before the City Name.

commaCountWinnerRows <- str_count(pageLinesNoBlanks[winnerRowFlags], ",")


splitWinnerRows <- strsplit(pageLinesNoBlanks[winnerRowFlags], " {4,}")


firstColumns <- lapply(splitWinnerRows,
                       function(x) {
                         l = length(x)
                         x[1:(l-1)]
                       })


replacementColumns <- lapply(splitWinnerRows,
                             function(x, n=6) {
                               l = length(x)
                               paste(strrep(" , ", (n-l)), x[l])
                             }
)


#newWinnerRowsList <- mapply(c, firstColumns, replacementColumns, SIMPLIFY = TRUE)


#newWinnerRows <- lapply(newWinnerRowsList, function(x) {
#  paste(x, collapse = ",")
#}
#)


# The newWinnerRows should each have 6 columns.  Rows with more columns are due to:
# data entry errors that include a zipcode at the end of the winner row. Fortunately, this extra information can be ignored since it doesn't include any useful information.  It is unclear which other column position errors may arise in the data sets.

```









